# 服务间通信方式

在整个微服务（基于单体业务，围绕业务进行服务拆分，拆分出来的每一个服务独立应用、独立运行、独立部署，并运行在自己的计算机进程中，基于分布式管理）架构中，我们比较关心的就是==服务间的服务该如何调用，有哪些调用方式==？

- 基于 HTTP 协议、使用 REST 方式通信
    - 使用 HTTP 协议进行数据传输——JSON（<font color=red>Spring Cloud 使用 HTTP  协议传输数据！</font>只要都支持 HTTP 协议，而不要求统一由 Java、Python、C++ 等开发实现——<font color=red>解耦合</font>），但效率较 RPC 低。
- RPC：远程过程调用
    - 传输二进制对象序列化形式数据（传输效率高，但对硬件要求高——<font color=red>服务必须都基于同一种语言开发</font>：Java 对 Java）

总结：在 Spring Cloud 中服务间调用方式主要是使用 HTTP、REST 方式进行服务间调用！

# 基于 RestTemplate 的服务调用

Spring 框架提供的 RestTemplate 类（一个 HTTP 客户端，使用它可以方便的调用 HTTP 接口，支持 GET、POST、PUT、DELETE 等方法）可用于在应用中调用 REST 服务，它简化了与 HTTP 服务的通信方式，统一了 RESTful 的标准，封装了 HTTP 链接， 只需要传入 url 及返回值类型即可。相较于之前常用的 HttpClient，RESTTemplate 是一种更优雅的调用 RESTful 服务的方式。

## GET 请求方法

```java
<T> T getForObject(String url, Class<T> responseType, Object... uriVariables);

<T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables);

<T> T getForObject(URI url, Class<T> responseType);

<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables);

<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables);

<T> ResponseEntity<T> getForEntity(URI var1, Class<T> responseType);
```

### getForObject 方法

返回对象为响应体中==数据转化成的对象==：

```java
@GetMapping("/{id}")
public CommonResult getUser(@PathVariable Long id) {
    return restTemplate.getForObject(userServiceUrl + "/user/{1}", CommonResult.class, id);
}
```

### getForEntity 方法

返回对象为 ResponseEntity 对象，包含了响应中的一些重要信息，比如==响应头、响应状态码、响应体==等：

```java
@GetMapping("/getEntityByUsername")
public CommonResult getEntityByUsername(@RequestParam String username) {
    ResponseEntity<CommonResult> entity = restTemplate.getForEntity(userServiceUrl + "/user/getByUsername?username={1}", CommonResult.class, username);
    if (entity.getStatusCode().is2xxSuccessful()) {
        return entity.getBody();
    } else {
        return new CommonResult("操作失败", 500);
    }
}
```

## POST 请求方法

```java
<T> T postForObject(String url, @Nullable Object request, Class<T> responseType, Object... uriVariables);

<T> T postForObject(String url, @Nullable Object request, Class<T> responseType, Map<String, ?> uriVariables);

<T> T postForObject(URI url, @Nullable Object request, Class<T> responseType);

<T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType, Object... uriVariables);

<T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType, Map<String, ?> uriVariables);

<T> ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType);
```

### postForObject

```java
@PostMapping("/create")
public CommonResult create(@RequestBody User user) {
    return restTemplate.postForObject(userServiceUrl + "/user/create", user, CommonResult.class);
}
```

### postForEntity

```java
@PostMapping("/create")
public CommonResult create(@RequestBody User user) {
    return restTemplate.postForEntity(userServiceUrl + "/user/create", user, CommonResult.class).getBody();
}
```

## 实例

### 创建项目、引入依赖、写配置

创建两个服务并注册到 consul 注册中心中：

依赖：

```xml
<dependencies>
    <!--引入SpringBootWeb依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!--引入Consul依赖-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-consul-discovery</artifactId>
    </dependency>

    <!-- 引入健康监控依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
```



- ConsulClientUser：代表用户服务，端口为 9998

- ConsulClientOrder：代表订单服务，端口为 9999

    - 配置文件

    ```properties
    server.port=9999
    spring.application.name=ConsulClientOrder
    
    # 注册consul服务主机
    spring.cloud.consul.host=localhost
    # 注册consul服务注册中心的端口号
    spring.cloud.consul.port=8500
    ```

    - 入口类

    ```java
    package com.example;
    
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
    
    @SpringBootApplication
    @EnableDiscoveryClient
    public class ConsulClientOrderApplication {
        public static void main(String[] args) {
            SpringApplication.run(ConsulClientOrderApplication.class, args);
        }
    }
    ```

### 在订单服务中提供服务方法

```java
package com.example.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@Slf4j
public class OrderController {
    @Value("${server.port}")
    private Integer port;

    @GetMapping("FindOrder")
    public Map<String, Object> findOrder() {
        log.info("查询所有订单，调用成功！当前服务端口：{}", port);
        Map<String, Object> map = new HashMap<>();
        map.put("message", "服务调用成功，服务提供端口为：" + port);
        map.put("state", true);
        return map;
    }
}
```

### 在用户服务中使用 restTemplate 进行订单服务调用

```java
package com.example.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
@Slf4j
public class UserController {
    @GetMapping("UserInvokeOrder")
    public String invokeOrder() {
        log.info("用户信息服务调用订单服务。。。");
        // 使用 restTemplate 发起请求，调用商品服务
        RestTemplate restTemplate = new RestTemplate();
        // <T> T getForObject(URI url, Class<T> responseType)
        String orderResult = restTemplate.getForObject("http://localhost:9999/FindOrder", String.class);
        return "调用订单服务成功，结果为：" + orderResult;
    }
}
```

### 测试

先启动“服务注册中心”，再启动两个服务！

```markdown
>consul agent -dev
```

浏览器访问用户服务http://localhost:9998/UserInvokeOrder，页面输出

```markdown
调用订单服务成功，结果为：{"state":true,"message":"服务调用成功，服务提供端口为：9999"}
```

`ConsulClientUserApplication :9998/`后台输出

```markdown
com.example.controller.UserController    : 用户信息服务调用订单服务。。。
```

`ConsulClientOrderApplication :9999/`后台输出

```markdown
com.example.controller.OrderController   : 查询所有订单，调用成功！当前服务端口：9999
```



### 基于 RestTemplate 调用服务的弊端

==RestTemplate 是直接基于服务地址调用，没有在服务注册中心获取服务，也没有办法完成服务的负载均衡==。如果需要实现服务的负载均衡，需要自己书写服务负载均衡策略。

- ==调用服务的请求路径写死在代码中==，日后提供服务的服务路径发生改变时，不利于后续维护工作！

    ```java
    RestTemplate restTemplate = new RestTemplate();
    // RestTemplate 将地址与端口写死了
    String orderResult = restTemplate.getForObject("http://localhost:9999/FindOrder", String.class);
    ```

    

- `RestTemplate`在进行服务间通信时，调用服务的路径主机和服务端口直接被写死在`url`中，==无法实现在服务集群情况下的请求负载均衡==！

    - 自定义负载均衡策略（例如随机选择节点）

        ```java
        public String randomHost() {
            List<String> hosts = new ArrayList<>();
            hosts.add("localhost:8888");
            hosts.add("localhost:8889");
            int i = new Random.nextInt(hosts.size());
            return hosts.get(i);
        }
        ```

        

    - 使用 Spring Cloud 提供的组件：Ribbon（推荐）
